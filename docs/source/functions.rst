=======
Функции
=======

--------------------------------------------
Нормализация страны - normalize_country_name
--------------------------------------------

**Аргументы и возвращаемое значение**

Функция имеет вид: **normalize_country_name(posname, dif_acc=0.7)**

Принимает на вход один обязательный аргумент **posname** (от "possible name") типа **string** - нормализуемое название, и один необязательный - **dif_acc** 
(от difference accuracy) типа **float** - параметр точности при поиске подходящего ключа в библиотеке, принимающий значения от **0.0** до **1.0** (по умолчанию - **0.7**). 

Выдает строку типа **string**, содержащую либо общее название страны, либо **'None'**, если выполнение прошло успешно. Если было вызвано исключение, то строка содержит 
**'DatabaseError'** (это означает, что не найдена корректная база данных по пути из переменной **DB_PATH**) или **'Invalid arguments'**, если хотя бы один из 
аргументов задан неправильно (имеет некорректный тип или значение).

**Логика работы**

В функции преобразуется входная строка **posname** и находится ближайший по расстоянию между строками ключ (**dif_acc** определяет минимальное расстояние, 
при котором строки считаются похожими). Для этого предпринимаются следующие шаги:

#. Удаление пунктуации и приведение к нижнему регистру: 

    Из входной строки **posname** удаляются символы, обозначающие пунктуацию (кроме используемых в названиях стран и пробелов). Для реализации используется список 
	символов пунктуации, чтобы избежать конфликтов с национальными символами для различных языков. Иной возможный способ реализации - регулярное выражение. 
	Также **posname** приводится к нижнему регистру, что позволяет сравнивать его с ключами (которые все записаны в нижнем регистре). 
	Таким образом достигается нечувствительность к регистру входной строки.
	
#. Поиск совпадения всей строки:

    2.1. Без удаления пробелов из входной строки:

        2.1.1. И ключа с приоритетом "1":

            С помощью функции **get_close_matches** из модуля **difflib** 
            стандартной библиотеки языка Python находим для строки **posname** ближайший по расстоянию между строками ключ с приоритетом **1** из нашей базы данных. 
	    При этом проверяем разность длин совпавшего ключа и входной строки без пробелов. Если эта разность по модулю не больше 1, то есть длины примерно равны, 
	    то значение по полученному ключу возвращается функцией и ее работа завершается.
        
        2.1.2. И ключа с приоритетом "2":

            Аналогично 2.1.1, различие только в приоритете.
		 

    2.2. С удалением пробелов из входной строки:

        2.2.1. И ключа с приоритетом "1":

            Удаляются все пробелы из входной строки, затем аналогично 2.1.1 (разность длин высчитывается между ключом без пробелов и входной строкой без пробелов)

        2.2.2. И ключа с приоритетом "2":
 
            Аналогично 2.2.1, различие в приоритете

#. Разбиение входной строки на слова (разделитель - ' '(пробел))

#. Поиск совпадения слов из входной строки:

    4.1. И ключа с приоритетом "1". При этом:

        4.1.1. Длины ключа и слова примерно равны

            Если найден такой ключ, то функция возвращает значение по этому ключу и завершает работу. Если нет, то выполнение продолжается по указанному порядку.

        4.1.2. Длины ключа и слова не равны

            Аналогично пункту 4.1.1, но без сравнения длины строк.

    4.2. И ключа с приоритетом "2". При этом:

        4.2.1. Длины ключа и слова примерно равны

            Аналогично 4.1.1, разница в приоритете ключей.

        4.2.2. Длины ключа и слова не равны

            Аналогично 4.1.2, разница в приоритете ключей.

#. Завершение работы - совпадения не найдено
    Если функция дошла до этого этапа, значит для входной строки не существует похожего ключа из базы данных, поэтому мы не можем точно сказать, 
	какая страна имелась в виду, и функция возвращает строку **'None'**. Eсли тип переданных аргументов некорректен, функция возвращает строку **'Invalid arguments'**. 
	Если же в процессе выполнения функции было вызвано исключение, то функция возвращает строку **'DatabaseError'** (с огромной вероятностью это означает, что не найдена 
	корректная база данных по пути из переменной **DB_PATH**)

Такая структура позволяет охватить многие возможные опечатки и странные варианты. Например, удаление символов пунктуации и приведение к нижнему регистру позволяет 
корректно определить страну в случаях "America!!!" и "uNITED kINGDOM", а приоритет ключей разрешает ситуации типа "американского Парижа" - по запросу "Paris, US" функция 
вернет "Unated States". Cравнение длины ключа и строки (слова) нужно для того, чтобы сначала исключить варианты, когда совпало только начало или другая часть 
строки (слова), а удаление пробелов при проверки всей строки позволяет распознать "Russia" в строке "R U S S I A".

А также, так как значение записывается вместе с приоритетом перед ним в одну строку, то нулевой элемент строки значения не учитывается при возвращении строки. То есть, в 
базе данных по ключу **'ru'** лежит значение **'1Russia'**, где **1** - приоритет ключа **'ru'**, и возвращается только часть строки значения: **'Russia'**

----------------------------------------------------------
Добавление возможного названия страны - match_country_name
----------------------------------------------------------

**Аргументы и возвращаемое значение**

Функция имеет вид: **match_country_name(key, value, priority=2)**

Принимает на вход два обязательных аргумента **key** и **value** типа **string** - возможное и корректное названия соответственно, и один необязательный - **priority** 
типа **int** - приоритет ключа, принимающий значения **1** или **2** (по умолчанию - **2**) и определяющий, что содержится в ключе: название, сокращение, индекс или 
перевод названия страны, если приоритет равен **1**, и все остальное, если приоритет равен **2**. Так как большинство ключей, подходящих под приоритет **1**, уже в базе, 
то возможно задать приоритет по умолчанию равный **2**. 

Выдает строку **'Invalid argumens'** типа **string** , если хотя бы один из аргументов задан неправильно (имеет некорректный тип или значение), 
строку **'DatabaseError'**, если произошла ошибка во время открытия базы данных по пути из переменной **DB_PATH**, и ничего не возвращает (**None**), 
если добавление прошло успешно.

**Логика работы**

Сначала функция проверяет типы и значения аргументов. Если проверка прошла успешно, то делается попытка открыть базу данных. Если база данных успешно открыта, то ключ 
(**key**, возможное название) приводится к нижнему регистру, значение (**value**, корректное название) объединяется с приоритетом (**priority**) в одну строку, и 
пара ключ-(приоритет+значение) записывается в базу данных. Если ключ уже находится в базе, то его значение перезаписывается.

------------------------------------------------------
Удаление возможного названия страны - del_country_name
------------------------------------------------------

**Аргументы и возвращаемое значение**

Функция имеет вид: **del_country_name(key)**

Принимает на вход один обязательный аргумент **key** типа **string** - возможное название, которое нужно удалить из базы данных.

Выдает строку **'Invalid arguments'** типа **string** , аргумент задан неправильно (имеет некорректный тип или значение), строку **'DatabaseError'**, 
если произошла ошибка во время открытия базы данных по пути из переменной **DB_PATH**, и ничего не возвращает (**None**), если удаление прошло успешно.

**Логика работы**

Сначала функция проверяет типы и значения переменных. Если проверка прошла успешно, то делается попытка открыть базу данных. Если база данных успешно открыта, 
то ключ (**key**, возможное название) приводится к нижнему регистру и проверяется на наличие в базе данных. Если ключ находится в базе, то он и его значение удаляются, 
и функция завершается. Если нет - то выполнение функции завершается сразу.
